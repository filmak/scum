This chapter provides an outline of the code changes required to create an ASIC version of the Single Chip Mote digital system using the Verilog code written for the Artix-7 FPGA. Most of the code is applicable to both FPGA and ASIC designs; however, the FPGA design requires primitives for clock division and ROM/RAM instantiation which are not available for ASIC designs. Most ASIC designs also implement scan chain and test logic to ensure that there are no manufacturing defects. Once the code changes are complete, the Verilog is synthesized using Synopsys Design Compiler, and the final layout is created using Synopsys IC Compiler. The layout is then combined with the required analog and RF circuits and sent for manufacturing.

Some of the changes described in this chapter are already implemented and added to a special branch in the git repo. These modifications were used to generate the results reported in Chapter \ref{intro}. The \texttt{asic-src} branch contains several new folders: 

\begin{itemize}
	\item \path{scm-digital/src/hw/scm_v2} for the updated Verilog source code
	\item \path{scm-digital/proj/modelsim} for the ModelSim project containing system-level testbenches for the updated code
	\item \path{scm-digital/proj/keil/asic_testbench_fw} and \path{scm-digital/src/sw/asic_testbench_fw} for the C code written into the ROM for the system-level testbenches
	\item \path{scm-digital/proj/keil/asic_testbench_sw} and \path{scm-digital/src/sw/asic_testbench_sw} for the C code written into the RAM for the system level testbenches 
\end{itemize}

The Synopsys toolchain and ModelSim simulator are installed and run on servers managed by the Berkeley Wireless Research Center (BWRC).

\section{Power-On Reset and Clock Generator}
The Single Chip Mote digital system implemented on the Artix-7 FPGA uses the \texttt{PON} module to generate the required clock and reset signals. This module uses FPGA primitives not available on ASIC designs and counter-based clock dividers which are relatively inaccurate. The ASIC version of the Single Chip Mote requires a separate analog circuit, with inputs and outputs to/from the digital system to handle clocks and resets. This analog circuit is responsible for:

\begin{itemize}
	\item Generating the 5MHz system clock
	\item Generating the 2MHz radio transmission clock (with the option of a clock enable signal)
	\item Generating the 500kHz radio timer clock (with the option of a clock enable signal), and ensuring that this clock is phase-aligned with the system clock
	\item Generating a 2MHz radio receive clock (with the option of a clock enable signal) using the input data from the radio transceiver
	\item Buffering the 3 Wire Bus clock from a pad on the chip
	\item Debouncing the input reset signal from a pad on the chip
	\item Sampling the reset request signal from the Cortex-M0
	\item Generating the two reset signals using the input reset and the reset request signal
\end{itemize}

All of the inputs and outputs to the \texttt{PON} module must be moved to the top module for the digital system.

\section{Memories}
The Single Chip Mote digital system implemented on the Artix-7 FPGA uses instantiated memories created in COREGenerator for the instruction ROM, instruction RAM, and data RAM. These memories must be replaced with memories generated by the appropriate memory compiler, and this process requires changes to the \texttt{AHBIMEM} and \texttt{AHBDMEM} modules. The radio controller also has two FIFOs to store TX and RX packet data, and the memories for those FIFOs must be implemented using two-port register files generated by the appropriate memory compiler. This requires changes to the \texttt{tx\_fifo\_mem} and \texttt{rx\_fifo\_mem} modules.

The memory compiler takes in the parameters of the memory (such as width, depth, and number of write enable signals), and generates the files describing the layout and behavior of that memory on an ASIC chip. The layout is used when creating the chip. The behavior is modeled in Verilog code and used for simulation. This behavioral model is also instantiated in the Verilog code for the Single Chip Mote digital system (in place of the memories used on the FPGA version), and the scripts that create the final chip know to use the layout generated by the memory compiler.

\section{Scan Chain Insertion and Debug Interface}
Most, if not all, ASIC designs include scan-chain registers to test the digital logic for manufacturing errors. The scan chain is used to apply input test vectors to a module and then read out the output of that module. A scan chain can also be used to control more advanced debug and benchmarking hardware included on the chip. JTAG is a commonly-used standard for scan chain insertion and control. The advantage of the JTAG standard is that hardware used to communicate with a chip via JTAG from a computer is commercially available. However, most researchers use their own custom scan chain and debug interface. This would require developing additional hardware and accompanying software to communicate with the chip through a test program executed from a computer. Similar to the bootloader, Verilog code can be written for an FPGA to communicate with both the debug interface on the chip and a computer using a serial port or USB. The advantage of a custom debug interface is the ability to implement more advanced features not found in the JTAG standard. In either case, scan chain insertion, where scan chain registers are placed throughout the design, is done in Synopsys Design Compiler, after the Verilog design is synthesized.

\section{Integrated Logic Analyzer}
Outside of the scope of the Single Chip Mote project, an integrated logic analyzer unit is being designed in collaboration with graduate student Nathaniel Mailoa and undergraduate student Jimin Yoon. This project, nicknamed BearClaw, intends to mimic the functionality of the ChipScope integrated logic analyzer, for the purposes of debugging ASIC designs. Multiple signals within a design are connected to the inputs of BearClaw (under the restriction that they are all in the same clock domain), and any subset of those signals can be sampled into a dedicated memory in real-time. BearClaw is designed such that any debug interface can be used to configure which signals to sample (of the ones that are permanently connected the inputs), the conditions for triggering a sample, and read the data out of the memory. Once the data is transferred to a computer, it can be arranged and plotted as digital waveforms for debugging purposes. The addition of BearClaw to the Single Chip Mote may aid in diagnosing transient errors that are difficult or impossible to replicate in simulation (for example, issues when sending or receiving radio packets).

\section{Optical Serial Interface}
The current method of bootloading allows the firmware to use the 3 Wire Bus, the radio, or UART to receive the main software code for the instruction RAM. Both the 3 Wire Bus and UART require a physical connection to the chip, which is inconvenient and unreliable if the chip is not soldered to a printed circuit board (PCB). Using the radio removes the need for a PCB; however, in order to ensure reliable delivery, the firmware should implement a network protocol stack, such as OpenWSN \cite{openwsn}, which requires larger and more complex firmware code.

An alternative solution is to add a low-power optical receiver, such as the one described in \cite{optical-wakeup}, to the Single Chip Mote. To keep the interface simple, data can be transmitted using a protocol similar to (or exactly the same as) UART, using light in place of a physical connection. This method is simple and lightweight in terms of both hardware and software, and has the added advantage that multiple Single Chip Motes can be programmed at once.

Unfortunately, the optical receiver circuit has not been implemented. Once it is complete, the Single Chip Mote Digital system can use a modified version of the \texttt{APBUART} module to connect to this circuit. The final steps are to write the proper firmware for the Single Chip Mote and design an optical transmitter.

\section{Changes to Top-Level IOs}
The external power-on reset and clock generator will require the following changes to the top level IOs:

\begin{itemize}
	\item Remove the \texttt{CLK} and \texttt{RESETn} inputs
	\item Remove the \texttt{tx\_clk} output and the \texttt{rx\_clk} input
	\item If present, remove the \texttt{clk\_3wb} input
	\item Add an input for \texttt{HCLK}, \texttt{CLK\_TX}, \texttt{CLK\_RX}, \texttt{CLK\_3WB}, and \texttt{CLK\_RFTIMER}. These clocks used to come from the \texttt{PON} module and connect to the rest of the system.
	\item Add an output for the clock enable signals, \texttt{CLK\_RX\_EN} and \texttt{CLK\_3WB\_EN}. There is also the option of adding outputs for \texttt{CLK\_TX\_EN} and \texttt{CLK\_RFTIMER\_EN}. The current \texttt{RFcontroller} module does not have a clock enable for \texttt{CLK\_TX} but this can be added if necessary. The current \texttt{RFTIMER} module does not have a clock enable for \texttt{CLK\_RFTIMER} but this can be added if necessary.
	\item Add an output for the \texttt{SYSRESETREQ} signal from the Cortex-M0.
	\item Add an input for the hard reset, \texttt{HARD\_RESETn}, and the soft reset, \texttt{HRESETn}. These resets used to come form the \texttt{PON} module and connect to the rest of the system.
\end{itemize}
\ \\
The chosen scan chain and debug interface will also have its own set of IOs. If an optical interface is added for bootloading, it will also require additional IOs.